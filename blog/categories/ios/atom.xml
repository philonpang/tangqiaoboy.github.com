<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 唐巧的技术博客]]></title>
  <link href="http://blog.devtang.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://blog.devtang.com/"/>
  <updated>2013-02-28T17:08:18+08:00</updated>
  <id>http://blog.devtang.com/</id>
  <author>
    <name><![CDATA[唐巧]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[分享iOS开发技巧的微信公共账号]]></title>
    <link href="http://blog.devtang.com/blog/2013/02/21/introduction-of-weixin-public-account/"/>
    <updated>2013-02-21T20:02:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2013/02/21/introduction-of-weixin-public-account</id>
    <content type="html"><![CDATA[<p><img src="/images/weixin-why.png"></p>

<p>记得我以前刚学iOS开发的时候，常常会遇到各种问题，身边没有人交流，遇到问题只能上网搜。虽然stackoverflow能解决大部分问题，但是还是很渴望和身边的一些同行进行讨论和交流。</p>

<p>后来，我组建了一个QQ群，尽力把自己通过各种渠道认识的iOS同行聚集到群里面，希望形成一个讨论环境。现在群里面加入了包括网易，腾讯，新浪，搜狐，美团，豆瓣等公司的iOS程序员以及一些自由职业者。因为大家都是比较有经验的开发者，所以每天大家的讨论不太多，但是都很有价值。</p>

<p>但是，我发现QQ群对于讨论的归档性太弱。很多有代表意义的讨论，对于其他人可能是有用的，但是由于群的归档性太差，随着时间流逝，这些信息无法被有效沉淀。</p>

<p>所以我想做一个尝试。我想把这个QQ群里面有价值的讨论信息整理归档到这个公共账号上。希望大部分iOS同行每天都能得到少量的，但是有价值的信息。对于特别有价值的信息，我也会在后期整理成博客，发表在博客上。</p>

<p>希望这能对你平时的工作有所帮助。</p>

<p>如果你感兴趣，那么可以扫描以下二维码加该账号为好友，或者在微信中搜索“iOS开发”。</p>

<p><img src="/images/weixin-qr.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设置应用内的系统控件语言]]></title>
    <link href="http://blog.devtang.com/blog/2013/01/23/set-ios-system-ui-language/"/>
    <updated>2013-01-23T21:05:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2013/01/23/set-ios-system-ui-language</id>
    <content type="html"><![CDATA[<p><img src="/images/bdj-rank.jpg"></p>

<p>在iOS应用中，有时候会需要调用系统的一些UI控件，例如：</p>

<ol>
<li>在UIWebView中长按会弹出系统的上下文菜单</li>
<li>在UIImagePickerController中会使用系统的照相机界面</li>
<li>在编译状态下的UITableViewCell，处于待删除时，会有一个系统的删除按钮。</li>
</ol>


<p>以上这些UI控件中，其显示的语言并不是和你当前手机的系统语言一致的。而是根据你的App内部的语言设置来显示。结果就是，如果你没有设置恰当的话，你的中文App可能会出现一些英文的控件文字。</p>

<!-- more -->


<p>例如下图中，一个名为“百思不得姐”的应用，其在AppStore免费总榜中排名前100，图书类分类榜排名第一的应用，就闹出了系统控件显示成了英文的笑话，在其软件界面中长按，就会出如下的菜单，可以看到，这个菜单的文字全是英文的：</p>

<p><img src="/images/ios-menu-1.jpg"></p>

<p>而正常的菜单应该是中文的，如下是新浪微博的正文长按之后的效果：</p>

<p><img src="/images/ios-menu-2.jpg"></p>

<p>如何解决这个问题呢？方法如下:</p>

<p>用vim直接打开工程的Info.plist文件，在文件中增加如下内容即可：</p>

<p>``` xml
   <key>CFBundleLocalizations</key>     <br/>
   <array></p>

<pre><code>       &lt;string&gt;zh_CN&lt;/string&gt;
       &lt;string&gt;en&lt;/string&gt;
</code></pre>

<p>   </array>
```</p>

<p>TO: 百思不得姐的开发者，不用谢：）你们应用的内容挺有意思的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谈ObjC对象的两段构造模式]]></title>
    <link href="http://blog.devtang.com/blog/2013/01/13/two-stage-creation-on-cocoa/"/>
    <updated>2013-01-13T10:15:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2013/01/13/two-stage-creation-on-cocoa</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>Objective-c语言在申请对象的时，需要使用两段构造(<a href="http://volonbolon.net/post/634999801/two-stage-creation-in-cocoa">Two Stage Creation</a>)的模式。一个对象的创建，需要先调用alloc方法或allocWithZone方法，再调用init方法或initWithSomething方法。如下是一个NSString对象的创建示例：</p>

<p><code>objc
NSString * str = [[NSString alloc] initWithString:@"http://blog.devtang.com"];
</code></p>

<p>由于该语言的对象创建方法和大多数其它语言（如C、C++、Java、JavaScript）都不一样，所以引起了我的好奇。是什么原因促使Objective-C做了这种设计，而又是什么原因促使大多数其它语言都采用"new"方法来一次性创建对象呢？</p>

<p>在看了<a href="http://www.amazon.com/Cocoa-Design-Patterns-Erik-Buck/dp/0321535022">《Cocoa Design Patterns》</a>一书（顺便吐槽一下该书中文版翻译质量不高，建议看英文版），并且做了一些调研之后，我将总结分享给大家，欢迎大家讨论。</p>

<!-- more -->


<h2>对象的创建</h2>

<p>我们先来看看在对象的创建过程中，alloc和init到底做了哪些事情。</p>

<h3>alloc方法</h3>

<p>根据苹果的<a href="https://developer.apple.com/library/mac/#documentation/cocoa/conceptual/CocoaFundamentals/CocoaObjects/CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW54">官方文档</a>。当对象创建时，cocoa会从应用程序的虚拟地址空间上为该对象分配足够的内存。cocoa会遍历该对象所有的成员变量，通过成员变量的类型来计算所需占用的内存。</p>

<p>当我们通过alloc或allocWithZone方法创建对象时，cocoa会返回一个未”初使化“过的对象。在这个过程中，cocoa除了上面提到的申请了一块足够大的内存外，还做了以下3件事：</p>

<ol>
<li>将该新对象的引用计数(Retain Count)设置成1。</li>
<li>将该新对象的isa成员变量指向它的类对象。</li>
<li>将该新对象的所有其它成员变量的值设置成零。（根据成员变量类型，零有可能是指nil或Nil或0.0）</li>
</ol>


<p>isa成员变量是在<a href="https://developer.apple.com/library/mac/#documentation/cocoa/Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/cl/NSObject">NSObject</a>中定义的，所以保证Cocoa的所有对象都带有此成员变量。借助该变量可以实现Cocoa对象在运行时的自省(Introspection)功能。</p>

<h3>init方法</h3>

<p>大部分情况下，我们都不希望所有成员变量都是零，所以init方法会做真正的初使化工作，让对象的成员变量的值符合我们程序逻辑中的初始化状态。例如，NSMutableString可能就会额外再申请一块字符数组，用于动态修改字符串。</p>

<p>init还有一个需要注意的问题。某些情况下，init会造成alloc的原本空间不够用，而第二次分配内存空间。所以下面的写法是错的：</p>

<p><code>objc
NSString * s = [NSString alloc];
[s init]; // 这儿init返回的地址可能会变。s原本的指针地址可能是无效的地址。
</code></p>

<p>为此，苹果引入了一个编程规范，让大家写的时候将alloc 和init写在一行。所以上面的代码正确的写法是</p>

<p><code>objc
NSString * s = [[NSString alloc] init];
</code></p>

<h3>new</h3>

<p>在后来，苹果也引入了类方法：new。但是由于历史原因，init方法是实例方法而非类方法，所以作为类方法的new，只能简单地等价于 alloc + init，不能指定init的参数，所以用处不大。苹果在设计上也禁止多次调用init方法，例如如下代码会抛出 NSInvalidArgumentException。</p>

<p><code>objc
NSString * str = [NSString new];
str = [str initWithString:@"Bar"];
</code></p>

<h2>为什么这么设计</h2>

<p>说回来文章开始时提出来问题，为什么苹果要这么设计而其它语言不这么设计？</p>

<p>上面提到，alloc其实不只干了申请内存的事情，还做了：
 1. 内存管理的事情，设置Retain Count。
 2. 运行时自省的功能，设置isa变量。
 3. 非逻辑性的初使化功能，设置所有成员变量为零。</p>

<p>简单看来，根据设计模式的Single Responsibility的设计原则，苹果觉得alloc和init是做的2件不同的事情，把这两件事情分开放在2个函数中，对于程序员更加清楚明了。更详细查阅文档后，我觉得这是由于历史原因，让苹果觉得alloc方法过于复杂，在历史上，alloc不仅仅是分配内存，还可以详细的指定该内存所在的内存分区（用NSZone表示）。这就是下面要提到的allocWithZone方法。</p>

<p>在<a href="http://www.amazon.com/Cocoa-Design-Patterns-Erik-Buck/dp/0321535022">《Cocoa Design Patterns》</a>一书也提到，早期苹果是建议程序员使用 allocWithZone来管理内存分配的，每个NSZone表示一块内存分区，allowWithZone方法可以允许对象从指定分区分配内存。了解到这段历史后，也不难理解苹果这么设计的原因了。因为在这种情况下，alloc要处理的情况复杂，和init放到一起不合适。</p>

<p>而对于大多数出生在90年代的语言来说(例如Java,JavaScript,C#)，由于内存具体的分配方案都不需要程序员操心了，所以就不需要单独为内存分配实现一个alloc方法了。</p>

<h2>后记</h2>

<h3>allocWithZone被废弃</h3>

<p>自从Mac OS X 10.5上引入了垃圾回收机制后，苹果就不建议程序员使用allocWithZone了，事实上，cocoa框架也会忽略allocWithZone指定的分区。苹果在文档中也<a href="https://developer.apple.com/library/mac/#documentation/cocoa/Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/allocWithZone:">提到</a>，allocWithZone仅仅是一个历史遗留设计了。下图是苹果的文档截图：</p>

<p><img src="/images/allocWithZone.png" title="" ></p>

<h3>Objective-C的历史</h3>

<p>Objective-C是一门非常老的语言。如果你查阅文档，你会发现它和C++出生在同一时代（两种语言的发行年份都是<a href="http://en.wikipedia.org/wiki/Stepstone">1983年</a>），都是作为C语言的面向对象的接班人被推出。当然，最终C++胜出。由于历史久远，Objective-C也无法有太多优秀的语言做参考，所以，有很多历史遗留的设计。在2007年苹果公司发布了Obj-C 2.0, 对其进行了大量改进。</p>

<p>在最近几年的WWDC大会上，每年苹果都会对Objective-C和其对应的LLVM编译器进行改进，例如WWDC2011推出的ARC，WWDC2012推出的Object Literals等。所以现在使用Objective-C做开发已经非常舒服了。期待苹果给开发者带来更多惊喜。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在iOS中使用ZXing库]]></title>
    <link href="http://blog.devtang.com/blog/2012/12/23/use-zxing-library/"/>
    <updated>2012-12-23T17:03:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2012/12/23/use-zxing-library</id>
    <content type="html"><![CDATA[<p><img src="/images/zxing-icon.png"></p>

<h2>前言</h2>

<p><a href="https://code.google.com/p/zxing/">ZXing</a>(<a href="https://github.com/zxing/zxing">Github镜像地址</a>)是一个开源的条码生成和扫描库（开源协议为<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache2.0</a>)。它不但支持众多的条码格式，而且有各种语言的实现版本，它支持的语言包括：Java, C++, C#, Objective-C, ActionScript和Ruby。</p>

<p>我上周在iOS项目开发中使用了ZXing的扫描二维码功能。在此总结一下如何将ZXing集成到已有的iOS工程中，分享给大家。</p>

<!-- more -->


<h2>集成步骤</h2>

<p>首先去Google Code或Github将ZXing的代码下载下来，整个工程比较大，我们只需要其中涉及iOS的部分，所以最好做一些裁剪。简单来说，我们只需要保留cpp和iphone这2个文件夹，其余的全部删掉。如下图所示：</p>

<p><img src="/images/zxing-step-1.png"></p>

<p>接着我们继续裁剪，对于cpp这个目录，只保留cpp/core/src/zxing下面的内容，其余内容也可以删掉了。但是整个目录结构必须保持原样。裁剪完后，整个目录结构如下所示：</p>

<p><img src="/images/zxing-step-2.png"></p>

<p>接下来，我们把裁剪后的zxing目录整个移动到我们的iOS项目的目录下，并且把上图中可以看到的ZXingWidget.xcodeproj文件拖动到我们的iOS工程中。</p>

<p>下一步，我们需要设置ZXing项目和我们原本的iOS项目之间的依赖关系。在我们的iOS项目的设置中，点击build phases tab，然后增加 Target Dependencies 和 Link binary，并且增加这些framework依赖：</p>

<pre><code>a. AVFoundation
b. AudioToolbox
c. CoreVideo
d. CoreMedia
e. libiconv
f. AddressBook
g. AddressBookUI
</code></pre>

<p>完成之后如下图所示：</p>

<p><img src="/images/zxing-step-3.png"></p>

<p>最后一步，在设置中增加如下2个header search path:</p>

<ul>
<li>./zxing/iphone/ZXingWidget/Classes</li>
<li>./zxing/cpp/core/src</li>
</ul>


<p>需要注意的是，第一个path要设置成循环查找子目录，而第二个不循环查找，如下图所示：</p>

<p><img src="/images/zxing-step-4.png"></p>

<p>恭喜你，完成这步之后，你就已经完成ZXing库的集成了。下面谈谈如何使用ZXing库来做二维码识别。</p>

<h2>二维码识别</h2>

<p>ZXing的iOS版本提供2种方法来做二维码识别功能，第一种方法比较简单，第二种方法比较复杂。我在做Demo时使用了第一种方法，做真正项目开发的时候使用了第二种方法，所以都给大家介绍一下。</p>

<h3>使用方法一</h3>

<p>ZXing直接提供了一个扫描二维码的View Controller，即ZXingWidgetController。在需要使用的界面代码中，加入文件依赖：</p>

<p>``` objc</p>

<h1>import &lt;ZXingWidgetController.h></h1>

<h1>import &lt;QRCodeReader.h></h1>

<p><code>
然后在需要扫描的时候，调用如下代码即可：
</code> objc
- (IBAction)scanPressed:(id)sender {
  ZXingWidgetController <em>widController = [[ZXingWidgetController alloc] initWithDelegate:self showCancel:YES OneDMode:NO];
  NSMutableSet </em>readers = [[NSMutableSet alloc ] init];
  QRCodeReader* qrcodeReader = [[QRCodeReader alloc] init];
  [readers addObject:qrcodeReader];
  [qrcodeReader release];
  widController.readers = readers;
  [readers release];
  [self presentModalViewController:widController animated:YES];
  [widController release];
}
```</p>

<p>在ZXing扫描有结果时，会调用如下回调函数：</p>

<p>``` objc</p>

<p>@protocol ZXingDelegate
- (void)zxingController:(ZXingWidgetController<em>)controller didScanResult:(NSString </em>)result;
- (void)zxingControllerDidCancel:(ZXingWidgetController*)controller;
@end</p>

<p>```</p>

<h3>使用方法二</h3>

<p>方法二与方法一的区别就相当于AVFoundation和UIImagePickerController的区别一样。简单来说，就是使用方法二比方法一更加麻烦，但是获得的可定制性更高。</p>

<p>使用方法二时，你需要自己用AVFoundation获得Camera返回的实时图象，然后转成UIImage，最后传给ZXing的Decoder类完成二维码的识别。由于使用AVFoundation涉及的代码略多，我写的示意代码如下：</p>

<p>``` objc</p>

<h1>import "Decoder.h"</h1>

<h1>import "TwoDDecoderResult.h"</h1>

<h1>import "QRCodeReader.h"</h1>

<ul>
<li>(void)viewDidLoad {
  // setup QR reader
  self.qrReader = [[NSMutableSet alloc ] init];
  QRCodeReader* qrcodeReader = [[QRCodeReader alloc] init];
  [self.qrReader addObject:qrcodeReader];
  self.scanningQR = NO;
  self.step = STEP_QR;
}</li>
</ul>


<p>// AVFoundation的回调函数
- (void)captureOutput:(AVCaptureOutput <em>)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection </em>)connection {</p>

<pre><code>// 第一步，将sampleBuffer转成UIImage
UIImage *image= [self getCaptureImage:sampleBuffer];
// 第二步，用Decoder识别图象
Decoder *d = [[Decoder alloc] init];
d.readers = self.qrReader;
d.delegate = self;
self.scanningQR = [d decodeImage:image] == YES ? NO : YES;
</code></pre>

<p>}
```</p>

<p>ZXing的Decoder类提供了以下回调函数获得识别结果：</p>

<p>``` objc
@protocol DecoderDelegate<NSObject>
@optional
- (void)decoder:(Decoder <em>)decoder willDecodeImage:(UIImage </em>)image usingSubset:(UIImage <em>)subset;
- (void)decoder:(Decoder </em>)decoder didDecodeImage:(UIImage <em>)image usingSubset:(UIImage </em>)subset withResult:(TwoDDecoderResult *)result {</p>

<pre><code>NSLog(@"result = %@", [result text]);
</code></pre>

<p>}
- (void)decoder:(Decoder <em>)decoder failedToDecodeImage:(UIImage </em>)image usingSubset:(UIImage <em>)subset reason:(NSString </em>)reason;
- (void)decoder:(Decoder *)decoder foundPossibleResultPoint:(CGPoint)point;</p>

<p>@end</p>

<p>```</p>

<h2>Trouble Shoot &amp; Tips</h2>

<p>我在使用中遇到了一些问题，主要是编译的问题。</p>

<ol>
<li>一个是找不到 <iostream> 头文件。解决方法：把用到ZXing的源文件扩展名由.m改成.mm。</li>
<li>报错：Undefined symbols for architecture armv7s，<a href="http://stackoverflow.com/questions/12968369/undefined-symbols-for-architecture-armv7-when-using-zxing-library-in-xcode-4-5">解决方法</a>：把ZXingWidget的一个build target参数："Build Active Architecture Only" 修改成 "NO".</li>
<li>报错：No such file or directory，出现该错误可能是你的Header Search Path写错了，或者就是你的zxing库的目录结构不是我上面强调的，好好检查一下吧。</li>
<li>如果你需要生成二维码做测试，推荐一个不错的在线生成二维码的网站：<a href="http://cli.im/">http://cli.im/</a></li>
</ol>


<h2>ZXing和OpenCV的兼容问题</h2>

<p>ZXing 2.1 和OpenCV 2.4.3的iOS库有一些兼容问题，他们对C++标准库的版本和编译器版本都有一些需求，造成满足一方了，另一方就编译不通过了。Stackoverflow上有人终于找到了一个让它们和平共处的方法，但是只适用于iOS5.0以上版本。正好我们的App只支持iOS5.0+，所以就搞定了。所以如果你也正好遇到这个问题，可以参考<a href="http://stackoverflow.com/questions/13498581/opencv-zxing-incompatibility-on-ios">这个贴子</a>。</p>

<p>希望本文对大家有用，Have Fun~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[StoryBoard--看上去很美]]></title>
    <link href="http://blog.devtang.com/blog/2012/12/15/do-not-use-storyboard/"/>
    <updated>2012-12-15T10:21:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2012/12/15/do-not-use-storyboard</id>
    <content type="html"><![CDATA[<h2>介绍</h2>

<p>StoryBoard是苹果在2011年的WWDC Session 309《Introducing Interface Builder Storyboarding》中介绍的Interface Builder的新功能。其基本想法是将原本的xib进行升级，引入一个容器用于管理多个xib文件，并且这个容器可以通过拖拽设置xib之间的界面跳转。而这个容器就是被苹果称做的StoryBoard。下图是一个Storyboard的截图。</p>

<p><img src="/images/enbrace-ios5-1.png"></p>

<!-- more -->


<h2>优点</h2>

<p>总体上来说，Storyboard有以下好处：</p>

<ol>
<li>你可以从storyboard中很方便地梳理出所有View Controller的界面间的调用关系。这一点对于新加入项目组的开发同事来说，比较友好。</li>
<li>使用Storyboard可以使用Table View Controller的Static Cell功能。对于开发一些Cell不多，但每个Cell都不一样的列表类设置界面会比较方便。</li>
<li>通过实现 - (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender 方法，每个View Controller的跳转逻辑都聚集在一处，这方便我们统一管理界面跳转和传递数据。</li>
<li>Storyboard可以方便将一些常用功能模块化和复用。例如WWDC2011年介绍Storyboard的视频就将微博分享功能模块化成一个单独的Storyboard。我在开发App时，也将例如通过第三方注册登录模块做成一个单独的Storyboard，便于以后复用。</li>
</ol>


<h2>缺点</h2>

<p>我在新项目使用Storyboard时，却发现它只是看上去很美，真正用起来，却有很多问题，我发现的问题有：</p>

<ol>
<li>首先它和xib一样，对版本管理是灾难。因为是它实际上的多个xib的集合，所以更容易让多人编辑产生冲突。苹果对storyboard的设计也不好，基本上你只要打开，什么都不做，这个文件就会被更改，所以冲突几乎是不可避免的---除非你不打开，实在不小心打开看了，需要在提交前回退成服务器上的版本。</li>
<li>Storyboard提供的 Static cell特性只适合于UITableViewController的子类。我很多时候的用法是一个TableView嵌套在另一个UIView中，static cell就不能用了。</li>
<li>segue的概念对于开发来说并不省事，如果是用程序内部trigger一个segue，那么需要在另一个回调的地方设置dest view controller的参数信息。</li>
</ol>


<h2>总结</h2>

<p>我仔细比较权衡了一下优缺点，最主要的问题是我的版本管理在多人协作开发时将陷入灾难，而这是完全不能接受的。而最主要的好处就是，你可以在一个类似白板的地方“一揽众山小“一样了解所有界面之间的切换关系，但这个有那么重要吗？我自已其实很清楚跳转逻辑，这个只是对新同事了解项目代码时有帮助，那我花一点时间直接给他讲讲画画不就搞定的吗？为了这点好处而让版本管理无法使用，是完全不能接受的。</p>

<p>所以最终我决定放弃使用StoryBoard了，这个“看上去很美”的功能有着不可接受的缺陷。现在看来，它仅适用于做一些Demo的开发。苹果一直没有处理好这类可视化界面设计功能的版本管理，象xib文件，虽然是xml格式的，但如果多人编辑了，合并起来也会很麻烦。所以业界好多同行都不用xib,直接用纯代码来写界面，虽然稍慢一点儿，但是工程很干净，也基本没有了多人协作的版本冲突问题。</p>
]]></content>
  </entry>
  
</feed>

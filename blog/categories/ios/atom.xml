<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 唐巧的技术博客]]></title>
  <link href="http://blog.devtang.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://blog.devtang.com/"/>
  <updated>2012-02-22T21:52:20+08:00</updated>
  <id>http://blog.devtang.com/</id>
  <author>
    <name><![CDATA[唐巧]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用GCD]]></title>
    <link href="http://blog.devtang.com/blog/2012/02/22/use-gcd/"/>
    <updated>2012-02-22T20:44:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2012/02/22/use-gcd</id>
    <content type="html"><![CDATA[<h2>什么是GCD</h2>

<p>Grand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。该方法在Mac OS X 10.6雪豹中首次推出，并随后被引入到了iOS4.0中。GCD是一个替代诸如NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术，它看起来象就其它语言的闭包(Closure)一样，但苹果把它叫做blocks。</p>

<!--More-->


<h2>应用举例</h2>

<p>让我们来看一个编程场景。我们要在iphone上做一个下载网页的功能，该功能非常简单，就是在iphone上放置一个按钮，点击该按钮时，显示一个转动的圆圈，表示正在进行下载，下载完成之后，将内容加载到界面上的一个文本控件中。</p>

<h3>不用GCD前</h3>

<p>虽然功能简单，但是我们必须把下载过程放到后台线程中，否则会阻塞UI线程显示。所以，如果不用GCD, 我们需要写如下3个方法：</p>

<ul>
<li>someClick 方法是点击按钮后的代码，可以看到我们用NSInvocationOperation建了一个后台线程，并且放到NSOperationQueue中。后台线程执行download方法。</li>
<li>download 方法处理下载网页的逻辑。下载完成后用performSelectorOnMainThread执行download_completed 方法。</li>
<li>download_completed 进行clear up的工作，并把下载的内容显示到文本控件中。</li>
</ul>


<p>这3个方法的代码如下。可以看到，虽然 开始下载 -> 下载中 -> 下载完成 这3个步骤是整个功能的三步。但是它们却被切分成了3块。他们之间因为是3个方法，所以还需要传递数据参数。如果是复杂的应用，数据参数很可能就不象本例子中的NSString那么简单了，另外，下载可能放到Model的类中来做，而界面的控制放到View Controller层来做，这使得本来就分开的代码变得更加散落。代码的可读性大大降低。</p>

<p>``` objc
static NSOperationQueue * queue;</p>

<ul>
<li><p>(IBAction)someClick:(id)sender {
  self.indicator.hidden = NO;
  [self.indicator startAnimating];
  queue = [[NSOperationQueue alloc] init];
  NSInvocationOperation * op = [[[NSInvocationOperation alloc] initWithTarget:self selector:@selector(download) object:nil] autorelease];
  [queue addOperation:op];
}</p></li>
<li><p>(void)download {
  NSURL * url = [NSURL URLWithString:@"http://www.youdao.com"];
  NSError * error;
  NSString * data = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error];
  if (data != nil) {</p>

<pre><code>  [self performSelectorOnMainThread:@selector(download_completed:) withObject:data waitUntilDone:NO];
</code></pre>

  } else {

<pre><code>  NSLog(@"error when download:%@", error);
  [queue release];
</code></pre>

<p>  }
}</p></li>
<li><p>(void) download_completed:(NSString *) data {
  NSLog(@"call back");
  [self.indicator stopAnimating];
  self.indicator.hidden = YES;
  self.content.text = data;
  [queue release];
}
```</p></li>
</ul>


<h3>使用GCD后</h3>

<p>如果使用GCD，以上3个方法都可以放到一起，如下所示：</p>

<p>``` objc</p>

<pre><code>// 原代码块一
self.indicator.hidden = NO;
[self.indicator startAnimating];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    // 原代码块二
    NSURL * url = [NSURL URLWithString:@"http://www.youdao.com"];
    NSError * error;
    NSString * data = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error];
    if (data != nil) {
        // 原代码块三
        dispatch_async(dispatch_get_main_queue(), ^{
            [self.indicator stopAnimating];
            self.indicator.hidden = YES;
            self.content.text = data;
        });
    } else {
        NSLog(@"error when download:%@", error);
    }
});
</code></pre>

<p>```</p>

<p>首先我们可以看到，代码变短了。因为少了原来3个方法的定义，也少了相互之间需要传递的变量的封装。</p>

<p>另外，代码变清楚了，虽然是异步的代码，但是它们被GCD合理的整合在一起，逻辑非常清晰。如果应用上MVC模式，我们也可以将View Controller层的回调函数用GCD的方式传递给Modal层，这相比以前用@selector的方式，代码的逻辑关系会更加清楚。</p>

<h2>GCD的定义</h2>

<p>简单GCD的定义有点象函数指针，差别是用 ^ 替代了函数指针的 * 号，如下所示：</p>

<p>``` objc</p>

<pre><code> // 申明变量
 (void) (^loggerBlock)(void);
 // 定义
</code></pre>

<p> loggerBlock = ^{</p>

<pre><code>      NSLog(@"Hello world");
 };
 // 调用
 loggerBlock();
</code></pre>

<p>```</p>

<p>但是大多数时候，我们通常使用内联的方式来定义它，即将它的程序块写在调用的函数里面，例如这样：</p>

<p>``` objc</p>

<pre><code> dispatch_async(dispatch_get_global_queue(0, 0), ^{
      // something
 });
</code></pre>

<p>```</p>

<h2>系统提供的dispatch方法</h2>

<p>为了方便地使用GCD，苹果提供了一些方法方便我们将block放在主线程 或 后台线程执行，或者延后执行。使用的例子如下：</p>

<p>``` objc</p>

<pre><code> //  后台执行：
 dispatch_async(dispatch_get_global_queue(0, 0), ^{
      // something
 });
 // 主线程执行：
 dispatch_async(dispatch_get_main_queue(), ^{
      // something
 });
 // 一次性执行：
 static dispatch_once_t onceToken;
 dispatch_once(&amp;onceToken, ^{
     // code to be executed once
 });
 // 延迟2秒执行：
 double delayInSeconds = 2.0;
 dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * NSEC_PER_SEC);
 dispatch_after(popTime, dispatch_get_main_queue(), ^(void){
     // code to be executed on the main queue after delay
 });
</code></pre>

<p>```</p>

<p>另外，GCD还有一些高级用法，例如让后台2个线程并行执行，然后等2个线程都结束后，再汇总执行结果。这个可以用dispatch_group, dispatch_group_async 和 dispatch_group_notify来实现，示例如下：</p>

<p>``` objc</p>

<pre><code> dispatch_group_t group = dispatch_group_create();
 dispatch_group_async(group, dispatch_get_global_queue(0,0), ^{
      // 并行执行的线程一
 });
 dispatch_group_async(group, dispatch_get_global_queue(0,0), ^{
      // 并行执行的线程二
 });
 dispatch_group_notify(group, dispatch_get_global_queue(0,0), ^{
      // 汇总结果
 });
</code></pre>

<p>```</p>

<h2>后台运行</h2>

<p>GCD的另一个用处是可以让程序在后台较长久的运行。在没有使用GCD时，当app被按home键退出后，app仅有最多5秒钟的时候做一些保存或清理资源的工作。但是在使用GCD后，app最多有10分钟的时间在后台长久运行。这个时间可以用来做清理本地缓存，发送统计数据等工作。</p>

<h2>总结</h2>

<p>总体来说，GCD能够极大地方便开发者进行多线程编程。如果你的app不需要支持iOS4.0以下的系统，那么就应该尽量使用GCD来处理后台线程和UI线程的交互。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给iOS工程增加Daily Build]]></title>
    <link href="http://blog.devtang.com/blog/2012/02/16/apply-daily-build-in-ios-project/"/>
    <updated>2012-02-16T19:27:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2012/02/16/apply-daily-build-in-ios-project</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>Daily Build是一件非常有意义的事情，也是敏捷开发中关于“持续集成”的一个实践。Daily Build对于开发来说有如下好处：</p>

<ul>
<li>保证了每次check in的代码可用，不会造成整个工程编译失败。</li>
<li>进度跟进。产品经理可以每天看到最新的开发进度，并且试用产品，调整一些细节。很多时候，一个新功能，你真正用了一下才能有体会好或不好，所以daily build也给产品经理更多时间来调理他的设计。</li>
<li>需求确认。产品经理可以确认开发的功能细节是他的预期。因为我们的开发比较紧凑，所以都没有传统的需求说明文档，所以daily build也给产品经理用于尽早确认开发的功能细节是他的预期，我就遇到一次产品经理发现开发出的一个功能细节和他的预期不一致，但是因为有daily build，使得我可以尽早做修改，把修改的代价减小了。</li>
<li>测试跟进。如果功能点是独立的话，测试同事完全可以根据daily build来进行一些早期的测试。越早的Bug反馈可以使得修改bug所需的时间越短。</li>
</ul>


<!--more-->


<h2>步骤</h2>

<h3>xcodebuild命令</h3>

<p>如何做daily build呢？其实Xcode就提供了命令行build的命令，这个命令是xcodebuild，用xcodebuild -usage
可以查看到所有的可用参数，如下所示：</p>

<p>``` bash
[tangqiao ~]$xcodebuild -usage
Usage: xcodebuild [-project <projectname>] [[-target <targetname>]...|-alltargets] [-configuration <configurationname>] [-arch <architecture>]... [-sdk [<sdkname>|<sdkpath>]] [<buildsetting>=<value>]... [<buildaction>]...</p>

<pre><code>   xcodebuild [-project &lt;projectname&gt;] -scheme &lt;schemeName&gt; [-configuration &lt;configurationname&gt;] [-arch &lt;architecture&gt;]... [-sdk [&lt;sdkname&gt;|&lt;sdkpath&gt;]] [&lt;buildsetting&gt;=&lt;value&gt;]... [&lt;buildaction&gt;]...
   xcodebuild -workspace &lt;workspacename&gt; -scheme &lt;schemeName&gt; [-configuration &lt;configurationname&gt;] [-arch &lt;architecture&gt;]... [-sdk [&lt;sdkname&gt;|&lt;sdkpath&gt;]] [&lt;buildsetting&gt;=&lt;value&gt;]... [&lt;buildaction&gt;]...
   xcodebuild -version [-sdk [&lt;sdkfullpath&gt;|&lt;sdkname&gt;] [&lt;infoitem&gt;] ]
   xcodebuild -list [[-project &lt;projectname&gt;]|[-workspace &lt;workspacename&gt;]]
   xcodebuild -showsdks
</code></pre>

<p>```</p>

<p>一般情况下的命令使用如下:</p>

<p><code>bash
xcodebuild -configuration Release -target "YourProduct"
</code></p>

<p>但在daily build中，用Release用为configuration其实不是特别好。因为Release的证书可能会被经常修改。我们可以基于Release的Configuation，建一个专门用于daily build的configuration。方法是：在工程详细页面中，选择Info一栏，在Configurations一栏的下方点击“+”号，然后选择"Duplicate Release Configuration", 新建名为"DailyBuild"的Configuration, 如下图所示：</p>

<p><img src="/images/daily_build_1.png"></p>

<p>之后就可以用如下命令来做daily build了</p>

<p><code>bash
xcodebuild -configuration DailyBuild -target "YourProduct"
</code></p>

<p>执行完命令后，会在当前工程下的 build/DailyBuild-iphoneos/目录下生成一个名为： YourProduct.app的文件。这个就是我们Build成功之后的程序文件。</p>

<h3>生成ipa文件</h3>

<p>接下来我们需要生成ipa文件，在生成ipa文件这件事情上，xcode似乎没有提供什么工具，不过这个没什么影响，因为ipa文件实际上就是一个zip文件，我们使用系统的zip命令来生成ipa文件即可。需要注意的是，ipa文件并不是简单地将编辑好的app文件打成zip文件，它需要将app文件放在一个名为Payload的文件夹下，然后将整个Payload目录打包成为.ipa文件，命令如下：</p>

<p><code>bash
cd $BUILD_PATH
mkdir -p ipa/Payload
cp -r ./DailyBuild-iphoneos/$PRODUCT_NAME ./ipa/Payload/
cd ipa
zip -r $FILE_NAME *
</code></p>

<h3>生成安装文件</h3>

<p>苹果允许用itms-services协议来直接在iphone/ipad上安装应用程序，我们可以直接生成该协议需要的相关文件，这样产品经理和测试同学都可以直接在设备上安装新版的应用了。相关的参考资料可以见：<a href="http://blog.encomiabile.it/2010/12/21/ios4-and-wireless-application-deploy/">这里</a>和 <a href="http://blog.s135.com/itms-services/">这里</a></p>

<p>具体来说，就是需要生成一个带 itms-services 协议的链接的html文件，以及一个 plist 文件。</p>

<p>生成html的示例代码如下：</p>

<p>``` bash
cat &lt;&lt; EOF > install.html
&lt;!DOCTYPE HTML>
<html>
  <head></p>

<pre><code>&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
&lt;title&gt;安装此软件&lt;/title&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;ul&gt;
  &lt;li&gt;安装此软件:&lt;a href="itms-services://?action=download-manifest&amp;url=http%3A%2F%2Fwww.yourdomain.com%2Fynote.plist"&gt;$FILE_NAME&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</code></pre>

<p>  </body>
</html>
EOF
```</p>

<p>生成plist文件的代码如下，注意，需要将下面的涉及 www.yourdomain.com的地方换成你线上服务器的地址，将ProductName换成你的app安装后的名字。</p>

<p>``` bash
cat &lt;&lt; EOF > ynote.plist
&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
   <key>items</key>
   <array></p>

<pre><code>   &lt;dict&gt;
       &lt;key&gt;assets&lt;/key&gt;
       &lt;array&gt;
           &lt;dict&gt;
               &lt;key&gt;kind&lt;/key&gt;
               &lt;string&gt;software-package&lt;/string&gt;
               &lt;key&gt;url&lt;/key&gt;
               &lt;string&gt;http://www.yourdomain.com/$FILE_NAME&lt;/string&gt;
           &lt;/dict&gt;
           &lt;dict&gt;
               &lt;key&gt;kind&lt;/key&gt;
               &lt;string&gt;display-image&lt;/string&gt;
               &lt;key&gt;needs-shine&lt;/key&gt;
               &lt;true/&gt;
               &lt;key&gt;url&lt;/key&gt;
               &lt;string&gt;http://www.yourdomain.com/icon.png&lt;/string&gt;
           &lt;/dict&gt;
       &lt;dict&gt;
               &lt;key&gt;kind&lt;/key&gt;
               &lt;string&gt;full-size-image&lt;/string&gt;
               &lt;key&gt;needs-shine&lt;/key&gt;
               &lt;true/&gt;
               &lt;key&gt;url&lt;/key&gt;
               &lt;string&gt;http://www.yourdomain.com/icon.png&lt;/string&gt;
           &lt;/dict&gt;
       &lt;/array&gt;&lt;key&gt;metadata&lt;/key&gt;
       &lt;dict&gt;
           &lt;key&gt;bundle-identifier&lt;/key&gt;
           &lt;string&gt;com.yourdomain.productname&lt;/string&gt;
           &lt;key&gt;bundle-version&lt;/key&gt;
           &lt;string&gt;1.0.0&lt;/string&gt;
           &lt;key&gt;kind&lt;/key&gt;
           &lt;string&gt;software&lt;/string&gt;
           &lt;key&gt;subtitle&lt;/key&gt;
           &lt;string&gt;ProductName&lt;/string&gt;
           &lt;key&gt;title&lt;/key&gt;
           &lt;string&gt;ProductName&lt;/string&gt;
       &lt;/dict&gt;
   &lt;/dict&gt;
</code></pre>

<p>   </array>
</dict>
</plist></p>

<p>EOF</p>

<p>```</p>

<h3>定时运行</h3>

<p>这一点非常简单，使用crontab -e命令即可。大家可以随意google一下crontab命令，可以找到很多相关文档。假如我们要每周1-5的早上9点钟执行daily build，则crontab的配置如下：</p>

<p><code>
0 9 * * * 1-5 /Users/tangqiao/dailybuild.sh &gt;&gt; /Users/tangqiao/dailybuild.log 2&gt;&amp;1
</code></p>

<h3>失败报警</h3>

<p>在daily build脚本运行失败时，最好能发报警邮件或者短信，以便能够尽早发现。发邮件可以用python的smtplib来写，示例如下：</p>

<p>``` python
import smtplib</p>

<p>sender = 'sender@devtang.com'
receivers = ['receiver@devtang.com']</p>

<p>message = """From: Alert <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#115;&#x65;&#110;&#x64;&#101;&#114;&#x40;&#100;&#x65;&#118;&#x74;&#97;&#x6e;&#103;&#x2e;&#x63;&#x6f;&#x6d;">&#115;&#x65;&#x6e;&#100;&#x65;&#x72;&#x40;&#x64;&#x65;&#x76;&#x74;&#x61;&#110;&#x67;&#46;&#x63;&#111;&#109;</a>
To: Some one <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#58;&#x72;&#101;&#x63;&#101;&#x69;&#x76;&#101;&#114;&#64;&#x64;&#x65;&#x76;&#116;&#97;&#x6e;&#x67;&#x2e;&#99;&#111;&#109;">&#114;&#x65;&#x63;&#101;&#105;&#x76;&#x65;&#114;&#x40;&#100;&#x65;&#118;&#116;&#97;&#x6e;&#x67;&#x2e;&#x63;&#x6f;&#109;</a>
Subject: SMTP email sample</p>

<p>Hope you can get it.
"""</p>

<p>try:</p>

<pre><code>obj = smtplib.SMTP('server.mail.devtang.com')
obj.sendmail(sender, receivers, message)
print 'OK: send mail succeed'
</code></pre>

<p>except Exception:</p>

<pre><code>print 'Error: unable to send mail'
</code></pre>

<p>```</p>

<h3>上传</h3>

<p>daily build编译出来如果需要单独上传到另外一台web机器上，可以用ftp或者scp协议。如果web机器悲剧的是windows机器的话，可以在windows机器上开一个共享，然后用 mount -t smbfs来将这个共享mount到本地，相关的示例代码如下：
``` bash
mkdir upload
mount -t smbfs //$SMB_USERNAME:$SMB_PASSWORD@$SMB_TARGET ./upload
if [ "$?" -ne 0 ]; then</p>

<pre><code>echo "Failed to mount smb directory"
exit 1
</code></pre>

<p>fi
mkdir ./upload/$FOLDER
cp $FILE_NAME ./upload/$FOLDER/
if [ "$?" -eq 0 ]; then</p>

<pre><code>echo "[OK] $FILE_NAME is uploaded to $SMB_TARGET" 
</code></pre>

<p>else</p>

<pre><code>echo "[ERROR] $FILE_NAME is FAILED to  uploaded to $SMB_TARGET" 
</code></pre>

<p>fi
umount ./upload
```</p>

<h2>总结</h2>

<p>将以上各点结合起来，就可以用bash写出一个daily build脚本了。每天这一切都会自动完成，心情相当好。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给NSString增加Java风格的方法]]></title>
    <link href="http://blog.devtang.com/blog/2012/02/14/nsstring-java-like-wrapper/"/>
    <updated>2012-02-14T17:17:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2012/02/14/nsstring-java-like-wrapper</id>
    <content type="html"><![CDATA[<p>我实在受不了NSString冗长的方法调用了，每次写之前都要查文档。特别是那个去掉前后多余的空格的方法，长得离谱。与之对应的别的语言，拿java来说，对应的方法名叫trim。拿python来说，对应的方法名叫strip。但是Objective-C呢？是下面这段：</p>

<p><code>objc
[self stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
</code></p>

<!--more-->


<p>其实我也明白Objective-C这种长函数名的好处，就是能很清楚地了解当前的方法是干什么的。但是一些常用的方法，简单的方法名同样能表达清楚意思，并且更容易记住。长方法名的最大的问题是，代码写到一半得查文档，直接把思路打断了，所以我上周末花了一天时间把Objective-C的NSString类给封装了一下，把相应的方法调用都换成与Java类似的了。这样我每次用的时候就不用写那么长又记不住的方法名了。</p>

<p>主要封装后的方法定义如下：</p>

<p><code>objc
@interface NSString(Wrapper)
- (unichar) charAt:(int)index;
- (int) compareTo:(NSString*) anotherString;
- (int) compareToIgnoreCase:(NSString*) str;
- (BOOL) contains:(NSString*) str;
- (BOOL) startsWith:(NSString*)prefix;
- (BOOL) endsWith:(NSString*)suffix;
- (BOOL) equals:(NSString*) anotherString;
- (BOOL) equalsIgnoreCase:(NSString*) anotherString;
- (int) indexOfChar:(unichar)ch;
- (int) indexOfChar:(unichar)ch fromIndex:(int)index;
- (int) indexOfString:(NSString*)str;
- (int) indexOfString:(NSString*)str fromIndex:(int)index;
- (int) lastIndexOfChar:(unichar)ch;
- (int) lastIndexOfChar:(unichar)ch fromIndex:(int)index;
- (int) lastIndexOfString:(NSString*)str;
- (int) lastIndexOfString:(NSString*)str fromIndex:(int)index;
- (NSString *) substringFromIndex:(int)beginIndex toIndex:(int)endIndex;
- (NSString *) toLowerCase;
- (NSString *) toUpperCase;
- (NSString *) trim;
- (NSString *) replaceAll:(NSString*)origin with:(NSString*)replacement;
- (NSArray *) split:(NSString*) separator;
@end
</code></p>

<p>看着方法体，一下子感觉轻松了好多，以后再也不必每次写的时候查文档了。代码放到github上了，你可以用如下命令获得代码或者直接访问网址<a href="https://github.com/tangqiaoboy/xcode_tool">https://github.com/tangqiaoboy/xcode_tool</a> ：</p>

<p><code>bash
git clone git@github.com:tangqiaoboy/xcode_tool.git
cd xcode_tool/NSStringWrappeer
</code></p>

<p>如果要把这个Wrapper加到现有工程中，只需要拷贝我的文件：NSStringWrapper.h和NSStringWrapper.m到你自己的工程中即可。在使用的时候注意我修改了一点，我将查找不存在的返回值设置成了-1，这样和java语言保持一致，如果你想用 NSNotFound作为查找不存在时的结果，请修改文件NSStringWrapper.m顶部的宏定义:JavaNotFound即可，如下所示：</p>

<p>``` objc
// 如果不喜欢，可以将-1改成 NSNotFound即可</p>

<h1>define JavaNotFound -1</h1>

<p>```</p>

<p>Have fun!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS5中UIViewController的新方法]]></title>
    <link href="http://blog.devtang.com/blog/2012/02/06/new-methods-in-uiviewcontroller-of-ios5/"/>
    <updated>2012-02-06T21:19:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2012/02/06/new-methods-in-uiviewcontroller-of-ios5</id>
    <content type="html"><![CDATA[<h3>前言</h3>

<p>在苹果的WWDC2011大会视频的
<a href="https://developer.apple.com/videos/wwdc/2011/?id=101">《Session 101 - What's New in Cocoa》</a> 和
<a href="https://developer.apple.com/videos/wwdc/2011/?id=102">《Session 102 - Implementing UIViewController Containment》</a> 中介绍了苹果在iOS5中给UIViewController新增加的5方法以及一个属性:</p>

<p><code>objc
// 方法
addChildViewController:
removeFromParentViewController:
transitionFromViewController:toViewController:duration:options:animations:completion:
willMoveToParentViewController:
didMoveToParentViewController:
// 属性
@property(nonatomic,readonly) NSArray *childViewControllers
</code></p>

<!--more-->


<h3>原来的问题</h3>

<p>这些新增的方法和属性用于改进我们的编程方式。那么让我们先看看以前的对于UIViewController的使用有什么潜在的问题，认清问题，我们才能理解苹果改变的意义。</p>

<p>在以前，一个UIViewController的View可能有很多小的子view。这些子view很多时候被盖在最后，我们在最外层ViewController的viewDidLoad方法中，用addSubview增加了大量的子view。这些子view大多数不会一直处于界面上，只是在某些情况下才会出现，例如登陆失败的提示view，上传附件成功的提示view，网络失败的提示view等。但是虽然这些view很少出现，但是我们却常常一直把它们放在内存中。另外，当收到内存警告时，我们只能自己手工把这些view从super view中去掉。</p>

<h3>改变</h3>

<p>苹果新的API增加了addChildViewController方法，并且希望我们在使用addSubview时，同时调用[self addChildViewController:child]方法将sub view对应的viewController也加到当前ViewController的管理中。对于那些当前暂时不需要显示的subview，只通过addChildViewController把subViewController加进去。需要显示时再调用transitionFromViewController:toViewController:duration:options:animations:completion方法。</p>

<p>另外，当收到系统的Memory Warning的时候，系统也会自动把当前没有显示的subview unload掉，以节省内存。</p>

<h3>参考资料</h3>

<p>关于这个，<a href="http://wangjun.easymorse.com/?p=1630">这儿</a>有一篇不错的文章介绍了一段sample代码用于演示新API的使用.</p>

<p>我也将其代码稍加修改，增加了view load, unload, appear, disappear的事件Log，以及收到Memory Warning时的Log。代码放在了github上，地址是<a href="https://github.com/tangqiaoboy/iOS5ViewCtrlerSample">这里</a>，感兴趣的同学可以自己下载下来看看源码。</p>

<p>可以看到，这些view在没有使用时，是不会被load的，并且当有Memory Warning时，当前没有显示的view自动被unload掉了。所以新的方法确实能有效地节省内存，也能方便地处理内存不足时的资源回收。运行Log如下：</p>

<p><code>
[7397:f803] -[FirstViewController willMoveToParentViewController:]
[7397:f803] -[SecondViewController willMoveToParentViewController:]
[7397:f803] -[ThirdViewController willMoveToParentViewController:]
[7397:f803] -[ThirdViewController viewDidLoad]
[7397:f803] -[ThirdViewController viewWillAppear:]
[7397:f803] -[ThirdViewController viewDidAppear:]
[7397:f803] 生日提醒
[7397:f803] -[SecondViewController viewDidLoad]
[7397:f803] -[ThirdViewController viewWillDisappear:]
[7397:f803] -[SecondViewController viewWillAppear:]
[7397:f803] -[SecondViewController viewDidAppear:]
[7397:f803] -[ThirdViewController viewDidDisappear:]
[7397:f803] 留言及回复
[7397:f803] -[FirstViewController viewDidLoad]
[7397:f803] -[SecondViewController viewWillDisappear:]
[7397:f803] -[FirstViewController viewWillAppear:]
[7397:f803] -[FirstViewController viewDidAppear:]
[7397:f803] -[SecondViewController viewDidDisappear:]
[7397:f803] Received memory warning.
[7397:f803] -[SecondViewController viewDidUnload]
[7397:f803] -[ThirdViewController viewDidUnload]
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[斯坦福大学iOS开发公开课总结]]></title>
    <link href="http://blog.devtang.com/blog/2012/02/05/mvc-in-ios-develop/"/>
    <updated>2012-02-05T12:58:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2012/02/05/mvc-in-ios-develop</id>
    <content type="html"><![CDATA[<h3>前言</h3>

<p>iphone开发相关的教程中最有名的，当数斯坦福大学发布的"iphone开发公开课"了。此公开课在以前叫做《iphone开发教程》，今年由于平板电脑的流行，所以也加入了ipad开发相关的课程。在<a href="http://v.163.com/special/opencourse/iphonekaifa.html">网易公开课</a>上，有<a href="http://v.163.com/special/opencourse/iphonekaifa.html">该教程</a>的2010年录象，并且前面15集带中文字幕文件，非常适合初学者学习。</p>

<!--more-->


<p>在这里顺便说一下，网易公开课上的28集其实并不需要全部看完。真正的课程只有前面12集。后面的课程都是请一些业界的名人讲他们成功的app以及学生的作品展示，可看可不看。所以大家不要被28集这么多吓到。</p>

<p>由于近一年来iOS5以及xcode4的发布，苹果对原有的开发环境xcode以及开发语言Objective-C都有改进，所以原有的教程中很多内容不再适用了。例如新的xcode4将Interface Builder集成到xcode中，整个IDE布局和快捷键完全大变样，又比如苹果为Objective-c引用了ARC和Storyboard，这些都使得app的编程方式大为不同。</p>

<p>值得高兴的是，斯坦福大学最近更新了该公开课的2011年秋季录象，免费下载地址是：<a href="http://itunes.apple.com/WebObjects/MZStore.woa/wa/viewPodcast?id=480479762">http://itunes.apple.com/WebObjects/MZStore.woa/wa/viewPodcast?id=480479762</a>，不过现在该公开课还没有翻译，只能看英文原版了。新的课程相比以前要短了许多，一共只有9课。我大概快速看了一遍，总结一些心得给大家。</p>

<h3>iOS的MVC模式</h3>

<p>MVC模式算是客户端类程序使用的设计模式的标配了。iOS对于Model, View和Controller之间的相互调用有它自己的规范和约定，在公开课的<a href="http://itunes.apple.com/itunes-u/ipad-iphone-application-development/id480479762#">第一课</a>中，就介绍了应该如何将MVC模式应用在iOS开发中。主要的内容就体现在如下这张图中(图片来自该公开课第一课的<a href="http://itunes.apple.com/itunes-u/ipad-iphone-application-development/id480479762#">配套pdf</a>的第37页)：</p>

<p><img src="/images/ios_mvc.jpg"></p>

<p>我下面详细介绍一下这幅图的意思。</p>

<ul>
<li><p>首先图中绿色的箭头表示直接引用。直接引用直观来说，就是说需要包含引用类的申明头文件和类的实例变量。可以看到，只有Controller中，有对Model和View的直接引用。其中对View的直接引用体现为IBOutlet。</p></li>
<li><p>然后我们看View是怎么向Controller通讯的。对于这个，iOS中有3种常见的模式:</p>

<ol>
<li>设置View对应的Action Target。如设置UIButton的Touch up inside的Action Target。</li>
<li>设置View的delegate，如UIAlertViewDelegate, UIActionSheetDelegate等。</li>
<li>设置View的data source, 如UITableViewDataSource。
通过这3种模式，View达到了既能向Controller通讯，又不需要知道具体的Controller是谁是目的，这样就和Controller解耦了。</li>
</ol>
</li>
<li><p>最后我们看Model。Model在图上有一个信号塔类似的图形，旁边写着Notification &amp; KVO。这表明Model主要是通过Notification和KVO来和Controller通讯的。关于Notification，我写了一个模版代码片段如下:（关于代码片段的管理，推荐大家看我写的另一篇文章：<a href="http://blog.devtang.com/blog/2012/02/04/use-git-to-manage-code-snippets/">使用Github来管理xcode4中的代码片段</a></p></li>
</ul>


<p><code>objc
// 监听通知
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(&lt;#methodName#&gt;) name:kLoginNotification object:nil];
// 取消监听
[[NSNotificationCenter defaultCenter] removeObserver:self];
// 发送通知
NSDictionary * userInfo = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt:200] forKey:@"code"];
[[NSNotificationCenter defaultCenter] postNotificationName:&lt;#notification_name#&gt; object:self userInfo:userInfo];
</code></p>

<p>所以，对于初学者，要正确地使用MVC模式还是挺难的，回想我们以前做公司某产品iphone版的时候，就有一些Model层直接依赖了Controller层，比如Model层更新数据失败了，直接调用Controller层显示出一个失败的提示界面。这样层次划分不清，造成我们做ipad版的时候很痛苦。最后我们做了代码重构，把Model的相应改变都用Notification来完成，使得在做ipad版开发时轻松了很多。</p>

<h3>Convention About synthesize</h3>

<p>“Convention over configuration"（约定高于配置）成就了Ruby On Rails，而iOS也有很多编程的约定。这些约定单独看没有什么好处，约定的最大好处就是，如果大家都遵守它，那么代码风格会趋于一致，你会很方便地读懂或修改别人的代码。</p>

<p>我们可以从第一课PPT的第50页看到如下的代码：</p>

<p><img src="/images/synthesize_convention.jpg"></p>

<p>从图中可以看到，该课程推荐大家在使用synthesize关键字时，为property设置一个下划线前缀。我也看过一些iphone的开源项目，比如facebook开源的 <a href="https://github.com/facebook/three20/">three20</a> ，它是遵守了这样的约定的。</p>

<p>其它的约定还包括：</p>

<ul>
<li>以new, copy, alloc开头的方法，都应当由调用者来release，而其它方法，都返回一个autorelease对象。</li>
<li>通常iphone顶部的bar应该用UINavigation控件，而底部的bar应该用UIToolbar控件。</li>
<li>所有的UI操作都应该在主线程(UI线程)进行。这个似乎不是约定，但是好多同学不知道，也写在这儿吧。</li>
</ul>


<h3>UIView</h3>

<p>刚开始对界面之间的跳转很不理解，后来发现其实很简单，就是一层一层叠起来的View。从View A上点击一个按钮跳转到View B，其实就是把View B“盖”在View A上面而已。
而“盖”的方式有好多种，通常的方法有2种：</p>

<p> 一. 用UINavigationController把View B push进来。
<code>objc
[self.navigationController pushViewController:nextView animated:YES];
</code></p>

<p> 二. 用presentModalViewController方法把View B盖在上面。</p>

<p><code>objc
[self presentModalViewController:nextView animated:YES];
</code></p>

<p>除此之外，其实还有一种山寨方法，即把View A和View B都用addSubView加到AppDelegate类的self.window上。然后就可以调用 bringSubviewToFront 把 View B显示出来了，如下所示：
<code>objc
// AppDelegate.m类
[self.window addSubview:viewB];
[self.window addSubview:viewA];
// 在需要时调用
[self.window bringSubviewToFront:viewB];
</code></p>

<p>上面说的是界面之间的跳转。对于一个界面内，其控件的布局其实也是一个一个叠起来的，之所以说叠，是指如果2个控件如果有重叠部分，那么处于上面的那个控件会盖住下面的。</p>

<h3>Nib File</h3>

<p>Nib文件实际上内部格式是XML，而它本身并不编译成任何二进制代码。所以你如果用iFile之类的软件在iPhone上查看一些安装好的软件的目录，可以看到很多的以nib结尾的文件，这些就是该软件的界面文件。虽然这些XML经过了一些压缩转换，但是我们还是可以看到一些信息，例如它使用了哪些系统控件等。</p>

<p>Nib文件刚开始给我的感觉很神秘，后来发现它其实就是用于可视化的编辑View类用的。其中的 File's Owner一栏，用于表示这个View对应的Controller类。通常情况下，Controller类会有一个名为view的变量，指向这个view的实例，我们也可以建立多个IBOutlet变量，指向这个view上的控件，以便做一些界面上的控制。</p>

<p>在Interface Builder上还有一个好处，是可以方便的将View的事件与Controller的IBAction绑定。只需要按住Ctrl键，从控件往File's Owner一栏拖拽，即可看到可以绑定的方法列表。其实这些只是简化了我们的工作，如果完全抛开Interface Builder，我们一样可以完成这些工作。我所知道业界的一些iOS开发部门，为了多人协作更加方便，更是强制不允许使用Interface Builder，一切界面工作都在代码中完成。如果你用文本编辑器打开Nib文件看过，就能理解这样做是有道理的。因为如果2个同时编辑一个界面文件，那么冲突的可能性是100%，而且，从svn结出的冲突信息上看，你根本无法修正它。下面的代码演示了如何不用Interface Builder来添加控件以及绑定UI事件。</p>

<p><code>objc
// SampleViewController.m的viewDidLoad方法片段
// 添加Table View控件
UITableView * tableView = [[UITableView alloc] initWithFrame:CGRectMake(0, 0, 320, 400)];
[self.view addSubview:tableView];
tableView.delegate = self;
[tableView release];
// 添加Button控件
self.button = [[[UIButton alloc] initWithFrame:CGRectMake(0, 0, 200, 100)] autorelease];
[self.view addSubview:self.button];
// 绑定事件
[self.button addTarget:self action:@selector(buttonPressed) forControlEvents:(UIControlEventTouchUpInside)];
</code></p>

<h3>总结</h3>

<p>总体来讲，学习iOS开发还是比较容易的。我大概花了一个月时间学习iPhone开发，就可以边做边学了。</p>

<p>苹果的设计对于开发者来说是非常友好的，很多时候使用相应的控件就行了，都不用操心底层细节。不象Android开发，一会儿要考虑不同手机分辨率不一样了，一会儿又要考虑有些不是触摸屏了，一会儿又发现某款手机的cpu内存太弱了跑不起来，需要优化程序。另外，Objective-C相对于C++语言来说，要简单优雅得多，而且更加强大，所以做iOS的开发者很省心。</p>

<p>要说到不爽的地方，就是iOS开发相关的中文资料实在是太少了。要学习它，基本上需要查看苹果的官方英文文档以及WWDC大会视频，还有去<a href="http://www.stackoverflow.com">stackoverflow</a>上问问题。这对于英文不太好的同学这可能是一个障碍。不过反过来，习惯之后，通过这个锻炼了自己的英文水平，倒也是一大收获。</p>
]]></content>
  </entry>
  
</feed>
